<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ブロックフォール</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a2e; /* Dark blue-purple background */
            color: #e0e0e0; /* Light text color */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars from game layout */
        }
        .game-container {
            display: flex;
            gap: 20px; /* Space between game board and info panel */
            padding: 20px;
            background-color: #2c2c54; /* Slightly lighter purple for container */
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        canvas {
            border: 3px solid #4a4a8a; /* Purple-ish border */
            border-radius: 8px;
            background-color: #0f0f1a; /* Very dark for game board itself */
        }
        .info-panel {
            width: 180px; /* Fixed width for info panel */
            display: flex;
            flex-direction: column;
            gap: 15px; /* Space between info items */
            color: #f5f5f5; /* Bright text for info */
        }
        .info-panel div {
            background-color: #3a3a6a; /* Darker purple for info boxes */
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9em;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
        }
        .info-panel h3 {
            font-size: 0.8em;
            margin-bottom: 8px;
            color: #aaa; /* Subdued color for headings */
            text-transform: uppercase;
        }
        .info-panel p {
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
        }
        #next-piece-canvas {
            width: 120px; /* Adjust based on max piece size (4x4) * BLOCK_SIZE_PREVIEW */
            height: 120px;
            background-color: #0f0f1a;
            border: 2px solid #4a4a8a;
            border-radius: 5px;
        }
        .button {
            font-family: 'Press Start 2P', cursive;
            background-color: #ff4757; /* Bright red for buttons */
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            text-transform: uppercase;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px #c0392b; /* 3D effect */
        }
        .button:hover {
            background-color: #e03e4f;
        }
        .button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #c0392b;
        }
        #game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 100;
        }
        #game-overlay h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: #ffdd59; /* Yellow for title */
        }
        #game-overlay p {
            font-size: 1em;
            margin-bottom: 30px;
            line-height: 1.6;
            max-width: 400px;
        }
        .hidden {
            display: none !important;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                padding-top: 10px; /* Add some padding for smaller screens */
            }
            .game-container {
                flex-direction: column;
                align-items: center;
                padding: 10px;
            }
            .info-panel {
                width: 100%; /* Full width on small screens */
                max-width: 300px; /* Max width for info panel on small screens */
                flex-direction: row; /* Arrange info items in a row */
                flex-wrap: wrap; /* Allow wrapping */
                justify-content: space-around; /* Distribute items */
                margin-top: 15px;
            }
            .info-panel div {
                flex-basis: 45%; /* Two items per row roughly */
                text-align: center;
            }
            #next-piece-canvas {
                margin: 0 auto; /* Center the next piece canvas */
            }
            #game-overlay h1 {
                font-size: 2em;
            }
            #game-overlay p {
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div id="game-overlay">
        <h1 id="overlay-title">ブロックフォール</h1>
        <p id="overlay-instructions">
            左右矢印キー: 移動<br>
            上矢印キー: 回転<br>
            下矢印キー: ソフトドロップ<br>
            スペースキー: ハードドロップ<br>
            ラインを揃えて消そう！
        </p>
        <button id="start-button" class="button">ゲーム開始</button>
    </div>

    <div class="game-container hidden">
        <canvas id="tetris-board"></canvas>
        <div class="info-panel">
            <div>
                <h3>スコア</h3>
                <p id="score">0</p>
            </div>
            <div>
                <h3>ライン</h3>
                <p id="lines">0</p>
            </div>
            <div>
                <h3>レベル</h3>
                <p id="level">1</p>
            </div>
            <div>
                <h3>NEXT</h3>
                <canvas id="next-piece-canvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        // --- Game Constants ---
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = Math.min(Math.floor((window.innerHeight * 0.8) / ROWS), Math.floor((window.innerWidth * 0.5) / COLS), 30); // Responsive block size
        const BOARD_WIDTH = COLS * BLOCK_SIZE;
        const BOARD_HEIGHT = ROWS * BLOCK_SIZE;

        const BLOCK_SIZE_PREVIEW = Math.floor(100 / 4); // For a 4x4 grid in preview

        const TETROMINOES = [
            { name: 'I', shape: [[1,1,1,1]], color: 'cyan' },
            { name: 'O', shape: [[1,1],[1,1]], color: 'yellow' },
            { name: 'T', shape: [[0,1,0],[1,1,1]], color: 'purple' },
            { name: 'S', shape: [[0,1,1],[1,1,0]], color: 'green' },
            { name: 'Z', shape: [[1,1,0],[0,1,1]], color: 'red' },
            { name: 'J', shape: [[1,0,0],[1,1,1]], color: 'blue' },
            { name: 'L', shape: [[0,0,1],[1,1,1]], color: 'orange' }
        ];

        const EMPTY_COLOR = '#0f0f1a'; // Background color of board cells
        const GRID_COLOR = '#33334d';

        // --- DOM Elements ---
        const canvas = document.getElementById('tetris-board');
        const context = canvas.getContext('2d');
        canvas.width = BOARD_WIDTH;
        canvas.height = BOARD_HEIGHT;

        const nextCanvas = document.getElementById('next-piece-canvas');
        const nextContext = nextCanvas.getContext('2d');
        nextCanvas.width = 4 * BLOCK_SIZE_PREVIEW; // Max piece width is 4 blocks
        nextCanvas.height = 4 * BLOCK_SIZE_PREVIEW; // Max piece height is 4 blocks

        const scoreElement = document.getElementById('score');
        const linesElement = document.getElementById('lines');
        const levelElement = document.getElementById('level');

        const gameOverlay = document.getElementById('game-overlay');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayInstructions = document.getElementById('overlay-instructions');
        const startButton = document.getElementById('start-button');
        const gameContainer = document.querySelector('.game-container');

        // --- Game State ---
        let board = createEmptyBoard();
        let currentPiece;
        let nextPiece;
        let score = 0;
        let lines = 0;
        let level = 1;
        let dropCounter = 0;
        let dropInterval = 1000; // ms per drop, decreases with level
        let lastTime = 0;
        let gameOver = false;
        let animationFrameId;

        // --- Game Logic Functions ---
        function createEmptyBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(EMPTY_COLOR));
        }

        function getRandomPiece() {
            const randIndex = Math.floor(Math.random() * TETROMINOES.length);
            const piece = TETROMINOES[randIndex];
            return {
                ...piece, // Copy name, shape, color
                x: Math.floor(COLS / 2) - Math.floor(piece.shape[0].length / 2),
                y: 0 // Start at the top
            };
        }

        // Rotate a matrix (tetromino shape)
        function rotate(matrix) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            const newMatrix = Array.from({ length: cols }, () => Array(rows).fill(0));
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (matrix[r][c]) {
                        newMatrix[c][rows - 1 - r] = matrix[r][c];
                    }
                }
            }
            return newMatrix;
        }
        
        // Collision detection
        function checkCollision(piece, boardState, offsetX = 0, offsetY = 0) {
            const shape = piece.shape;
            const x = piece.x + offsetX;
            const y = piece.y + offsetY;

            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) { // If it's a block part of the tetromino
                        const boardX = x + c;
                        const boardY = y + r;
                        // Check boundaries
                        if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
                            return true; // Collision with wall or bottom
                        }
                        // Check collision with landed blocks (only if boardY is positive, i.e., on the visible board)
                        if (boardY >= 0 && boardState[boardY][boardX] !== EMPTY_COLOR) {
                            return true;
                        }
                    }
                }
            }
            return false; // No collision
        }

        // Merge piece into board
        function mergePieceToBoard() {
            currentPiece.shape.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value) {
                        const boardX = currentPiece.x + c;
                        const boardY = currentPiece.y + r;
                        if (boardY >= 0) { // Only merge if on visible board
                           board[boardY][boardX] = currentPiece.color;
                        }
                    }
                });
            });
        }

        // Clear completed lines
        function clearLines() {
            let linesClearedThisTurn = 0;
            for (let r = ROWS - 1; r >= 0; ) {
                if (board[r].every(cell => cell !== EMPTY_COLOR)) {
                    // Line is full
                    board.splice(r, 1); // Remove the full row
                    board.unshift(Array(COLS).fill(EMPTY_COLOR)); // Add an empty row at the top
                    linesClearedThisTurn++;
                    // Don't decrement r, check the new row at this position
                } else {
                    r--; // Move to the row above
                }
            }

            if (linesClearedThisTurn > 0) {
                lines += linesClearedThisTurn;
                // Scoring based on lines cleared
                if (linesClearedThisTurn === 1) score += 100 * level;
                else if (linesClearedThisTurn === 2) score += 300 * level;
                else if (linesClearedThisTurn === 3) score += 500 * level;
                else if (linesClearedThisTurn >= 4) score += 800 * level; // Tetris!

                // Update level
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    dropInterval = Math.max(100, 1000 - (level - 1) * 75); // Decrease interval, min 100ms
                }
                updateScoreDisplay();
            }
        }
        
        function pieceDrop() {
            if (!checkCollision(currentPiece, board, 0, 1)) {
                currentPiece.y++;
            } else {
                // Piece has landed
                mergePieceToBoard();
                clearLines();
                currentPiece = nextPiece;
                nextPiece = getRandomPiece();
                if (checkCollision(currentPiece, board)) {
                    // Game Over
                    gameOver = true;
                    cancelAnimationFrame(animationFrameId);
                    showGameOverScreen();
                }
            }
            dropCounter = 0; // Reset drop counter after a move or landing
        }

        // --- Drawing Functions ---
        function drawBlock(contextToUse, x, y, color, blockSizeToUse) {
            contextToUse.fillStyle = color;
            contextToUse.fillRect(x * blockSizeToUse, y * blockSizeToUse, blockSizeToUse, blockSizeToUse);
            contextToUse.strokeStyle = GRID_COLOR; // Color for block borders
            contextToUse.strokeRect(x * blockSizeToUse, y * blockSizeToUse, blockSizeToUse, blockSizeToUse);
        }

        function drawBoard() {
            context.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
            // Draw landed blocks
            board.forEach((row, r) => {
                row.forEach((color, c) => {
                    if (color !== EMPTY_COLOR) {
                        drawBlock(context, c, r, color, BLOCK_SIZE);
                    } else { // Optionally draw empty grid cells for guidance
                        context.fillStyle = EMPTY_COLOR;
                        context.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        context.strokeStyle = GRID_COLOR;
                        context.strokeRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    }
                });
            });
        }

        function drawPiece(piece, ctx, blkSize) {
            if (!piece) return;
            ctx.fillStyle = piece.color;
            piece.shape.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value) {
                        drawBlock(ctx, piece.x + c, piece.y + r, piece.color, blkSize);
                    }
                });
            });
        }
        
        function drawNextPiece() {
            nextContext.fillStyle = EMPTY_COLOR; // Clear preview canvas
            nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            if (nextPiece) {
                const shape = nextPiece.shape;
                const color = nextPiece.color;
                const shapeRows = shape.length;
                const shapeCols = shape[0].length;

                // Calculate offsets to center the piece in the preview box
                const offsetX = Math.floor((nextCanvas.width / BLOCK_SIZE_PREVIEW - shapeCols) / 2);
                const offsetY = Math.floor((nextCanvas.height / BLOCK_SIZE_PREVIEW - shapeRows) / 2);

                shape.forEach((row, r) => {
                    row.forEach((value, c) => {
                        if (value) {
                            drawBlock(nextContext, offsetX + c, offsetY + r, color, BLOCK_SIZE_PREVIEW);
                        }
                    });
                });
            }
        }

        function updateScoreDisplay() {
            scoreElement.textContent = score;
            linesElement.textContent = lines;
            levelElement.textContent = level;
        }

        // --- Game Loop ---
        function gameLoop(currentTime) {
            if (gameOver) return;

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            dropCounter += deltaTime;

            if (dropCounter > dropInterval) {
                pieceDrop();
            }

            drawBoard();
            drawPiece(currentPiece, context, BLOCK_SIZE);
            drawNextPiece();
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Controls ---
        function handleKeyPress(event) {
            if (gameOver) return;
            if (!currentPiece) return;

            switch (event.key) {
                case 'ArrowLeft':
                    if (!checkCollision(currentPiece, board, -1, 0)) {
                        currentPiece.x--;
                    }
                    break;
                case 'ArrowRight':
                    if (!checkCollision(currentPiece, board, 1, 0)) {
                        currentPiece.x++;
                    }
                    break;
                case 'ArrowDown': // Soft drop
                    pieceDrop(); // Move down one step immediately
                    score += 1; // Small bonus for soft drop
                    updateScoreDisplay();
                    break;
                case 'ArrowUp': // Rotate
                    const rotatedShape = rotate(currentPiece.shape);
                    const originalShape = currentPiece.shape;
                    currentPiece.shape = rotatedShape;
                    if (checkCollision(currentPiece, board)) {
                        // If collision after rotation, try to "wall kick" (simple version)
                        // Try moving 1 right
                        if (!checkCollision(currentPiece, board, 1, 0)) {
                            currentPiece.x++;
                        } // Try moving 1 left
                        else if (!checkCollision(currentPiece, board, -1, 0)) {
                           currentPiece.x--;
                        } // Try moving 2 right (for I piece near wall)
                        else if (!checkCollision(currentPiece, board, 2, 0) && currentPiece.name === 'I') {
                            currentPiece.x += 2;
                        } // Try moving 2 left
                        else if (!checkCollision(currentPiece, board, -2, 0) && currentPiece.name === 'I') {
                            currentPiece.x -= 2;
                        } else { // If still collision, revert rotation
                            currentPiece.shape = originalShape;
                        }
                    }
                    break;
                case ' ': // Space for Hard Drop
                case 'Spacebar': // Some browsers use 'Spacebar'
                    let cellsDropped = 0;
                    while (!checkCollision(currentPiece, board, 0, 1)) {
                        currentPiece.y++;
                        cellsDropped++;
                    }
                    score += cellsDropped * 2; // Bonus for hard drop
                    pieceDrop(); // Finalize drop and lock
                    updateScoreDisplay();
                    break;
            }
            // Redraw immediately after input for responsiveness (optional, gameLoop handles it too)
            // drawBoard();
            // drawPiece(currentPiece, context, BLOCK_SIZE);
        }
        
        // --- UI Management ---
        function showStartScreen() {
            gameOverlay.classList.remove('hidden');
            gameContainer.classList.add('hidden');
            overlayTitle.textContent = "ブロックフォール";
            overlayInstructions.innerHTML = `
                左右矢印キー: 移動<br>
                上矢印キー: 回転<br>
                下矢印キー: ソフトドロップ<br>
                スペースキー: ハードドロップ<br>
                ラインを揃えて消そう！`;
            startButton.textContent = "ゲーム開始";
            startButton.onclick = initGame;
        }

        function showGameOverScreen() {
            gameOverlay.classList.remove('hidden');
            // gameContainer can remain visible to show final board state, or hide it:
            // gameContainer.classList.add('hidden'); 
            overlayTitle.textContent = "ゲームオーバー！";
            overlayInstructions.innerHTML = `
                最終スコア: ${score}<br>
                消したライン数: ${lines}<br>
                到達レベル: ${level}`;
            startButton.textContent = "もう一度プレイ";
            startButton.onclick = initGame;
        }

        // --- Initialization ---
        function initGame() {
            board = createEmptyBoard();
            currentPiece = getRandomPiece();
            nextPiece = getRandomPiece();
            score = 0;
            lines = 0;
            level = 1;
            dropInterval = 1000;
            gameOver = false;
            lastTime = 0;
            dropCounter = 0;
            
            updateScoreDisplay();
            
            gameOverlay.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        document.addEventListener('keydown', handleKeyPress);
        
        // Adjust canvas size on window resize
        window.addEventListener('resize', () => {
            const newBlockSize = Math.min(Math.floor((window.innerHeight * 0.8) / ROWS), Math.floor((window.innerWidth * 0.5) / COLS), 30);
            canvas.width = COLS * newBlockSize;
            canvas.height = ROWS * newBlockSize;
            // BLOCK_SIZE needs to be updated globally if other functions depend on its current value for drawing.
            // For simplicity, this example doesn't fully re-initialize BLOCK_SIZE for drawing after resize.
            // A more robust solution would re-calculate and potentially redraw everything or scale context.
            // For now, the initial calculation is based on screen size.
            // If the game is active, you might need to pause and redraw.
            if (!gameOver && currentPiece) { // Redraw if game is active
                 drawBoard();
                 drawPiece(currentPiece, context, newBlockSize); // Use newBlockSize if dynamic
                 drawNextPiece(); // Next piece preview might also need adjustment
            }
        });


        // Show start screen initially
        showStartScreen();

    </script>
</body>
</html>
